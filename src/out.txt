===== config.json =====
{
  "labels": ["a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"],
  "data": "data",
  "landmarks": "../../data/landmark_sequences",
  "images": "../../data/image_data",
  "camera": {
    "index": 0,
    "width": 640,
    "height": 480
  },
  "collection": {
    "sequence_len": 30,
    "def_samples": 30,
    "def_delay": 3
  },
  "mediapipe": {
    "max_hands": 2,
    "min_detection_confidence": 0.7,
    "min_tracking_confidence": 0.5
  }
}

===== config.py =====
import os
import json
from typing import Dict, Any

import cv2

class Config:
    
    def __init__(self, config_path: str = "./config.json"): 
        self.config_path = config_path
        self._load_config()

    def _load_config(self):
        script_dir = os.path.dirname(os.path.abspath(__file__))
        config_path = os.path.join(script_dir, self.config_path)
        JSONDATA: Dict[str, Any] = {}
        try:
            with open(config_path, "r") as f:
                JSONDATA = json.load(f)
            
            self.LABELS = JSONDATA["labels"]
            self.DATA_PATH = JSONDATA["data"]
            self.LANDMARKS_PATH = JSONDATA["landmarks"]
            self.IMAGES_PATH = JSONDATA["images"]
            self.CAMERA_IDX = JSONDATA["camera"]["index"]
            self.CAMERA_WIDTH = JSONDATA["camera"]["width"]
            self.CAMERA_HEIGHT = JSONDATA["camera"]["height"]
            self.SEQUENCE_LENGTH = JSONDATA["collection"]["sequence_len"]
            self.DEFAULT_SAMPLES = JSONDATA["collection"]["def_samples"]
            self.DEFAULT_DELAY = JSONDATA["collection"]["def_delay"]
            self.MAX_NUM_HANDS = JSONDATA["mediapipe"]["max_hands"]
            self.MIN_DETECTION_CONFIDENCE = JSONDATA["mediapipe"]["min_detection_confidence"]
            self.MIN_TRACKING_CONFIDENCE = JSONDATA["mediapipe"]["min_tracking_confidence"]

            self.COUNTDOWN_COLOR = (0, 0, 255) # palitan mo color pag d bagay sa UI
            self.COLLECTING_COLOR = (0, 255, 0)
            self.FONT = cv2.FONT_HERSHEY_SIMPLEX
            self.FONT_SCALE = 0.8
            self.FONT_THICKNESS = 2

        except Exception as e:
            raise ValueError(f"ERROR: Failed to load config: {e}")
        
    @property
    def landmarks_path(self) -> str: return self.LANDMARKS_PATH
    @property
    def images_path(self) -> str: return self.IMAGES_PATH

===== core_procs.py =====
from datetime import datetime
import logging
import os
from data_collection.config import Config
import mediapipe as mp
import numpy as np
from typing import Tuple, Any, List, Optional
from data_collection.data_models import LandmarksData
import cv2

class HandProcessor:
    def __init__(self, config: Config):
        self.config = config
        self.mp_hands = mp.solutions.hands # type: ignore
        self.mp_drawing = mp.solutions.drawing_utils # type: ignore
        self.hands = self.mp_hands.Hands(max_num_hands = config.MAX_NUM_HANDS, min_detection_confidence = config.MIN_DETECTION_CONFIDENCE, min_tracking_confidence = config.MIN_TRACKING_CONFIDENCE)

    def process_frame(self, frame: np.ndarray) -> Tuple[Any, List[LandmarksData]]: # type: ignore
        rgb_frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)  
        results = self.hands.process(rgb_frame)
        hand_landmarks = []
        if results.multi_handedness and results.multi_hand_landmarks:
            for index, hand_info in enumerate(results.multi_handedness):
                hand_label = hand_info.classification[0].label
                landmarks = results.multi_hand_landmarks[index]
                landmark_array = np.array([[lm.x, lm.y, lm.z] for lm in landmarks.landmark])
                hand_landmarks.append(LandmarksData(landmark_array, hand_label))
        return results, hand_landmarks
    
    def draw_landmarks(self, frame: np.ndarray, results: Any) -> np.ndarray:
        if results.multi_hand_landmarks:
            for hand_landmarks in results.multi_hand_landmarks:
                self.mp_drawing.draw_landmarks(
                    frame, hand_landmarks, self.mp_hands.HAND_CONNECTIONS
                )
        return frame
    
    def landmarks_to_vector(self, hand_landmarks: List[LandmarksData]) -> np.ndarray:
        left_hand = np.zeros((21, 3))
        right_hand = np.zeros((21, 3))
        for hand in hand_landmarks:
            if hand.hand_type == 'Left':
                left_hand = hand.normalized_landmarks
            else:
                right_hand = hand.normalized_landmarks
        return np.concatenate([left_hand.flatten(), right_hand.flatten()])
    
class CameraManager:
    def __init__(self, config: Config):
        self.config = config
        self.cap: Optional[cv2.VideoCapture] = None # type: ignore
        self.is_opened = False

    def initialize(self) -> bool:
        try:
            self.cap = cv2.VideoCapture(self.config.CAMERA_IDX)
            if self.cap.isOpened():
                self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, self.config.CAMERA_WIDTH)
                self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, self.config.CAMERA_HEIGHT)
                self.is_opened = True
                return True
        except Exception as e:
            logging.error(f"ERROR: Failed to init camera: {e}")
        return False
    
    def read_frame(self) -> Tuple[bool, Optional[np.ndarray]]: # type: ignore
        if not self.is_opened or not self.cap:
            return False, None
        
        ret, frame = self.cap.read()
        if ret:
            frame = cv2.flip(frame, 1) # da mirror epeks
        return ret, frame
    
    def release(self):
        if self.cap:
            self.cap.release()
        self.is_opened = False


class FileManager:
    def __init__(self, config: Config):
        self.config = config
        self._create_necessary_dirs()

    def _create_necessary_dirs(self):
        for subdir_path in [self.config.landmarks_path, self.config.images_path]:
            for label in self.config.LABELS:
                os.makedirs(os.path.join(subdir_path, label), exist_ok=True)

    def frame_image_save(self, frame: np.ndarray, label: str) -> str:
        file_name = f"{label}_{datetime.now().strftime('%Y%m%d%H%M%S')}.jpg"
        file_path = os.path.join(self.config.images_path, label, file_name)

        try:
            cv2.imwrite(file_path, frame)
            logging.info(f"INFO: Image saved: {file_path}")
            return file_path
        except Exception as e:
            logging.error(f"ERROR: Failed to save image: {e}")
            return ""
        
    def sequence_save(self, sequence: List[np.ndarray], label: str) -> str:
        file_name = f"{label}_{datetime.now().strftime('%Y%m%d%H%M%S')}.npy"
        file_path = os.path.join(self.config.landmarks_path, label, file_name)
        
        try:
            np.save(file_path, np.array(sequence))
            logging.info(f"INFO: Saved sequence: {file_path}")
            return file_path
        except Exception as e:
            logging.error(f"ERROR: Failed to save sequence: {e}")
            return ""
        


===== data_models.py =====
from datetime import datetime
from typing import List
import numpy as np


class LandmarksData:
    def __init__(self, landmarks: np.ndarray, hand_type: str):
        self.hand_type = hand_type
        self.landmarks = landmarks
        self.normalized_landmarks = self._normalize()
    def _normalize(self) -> np.ndarray:
        if self.landmarks.size == 0: return self.landmarks
        wrist = self.landmarks[0]
        normalized = self.landmarks = wrist
        scale = np.linalg.norm(normalized[9])
        return normalized / scale if scale > 0 else normalized
    def to_vector(self) -> np.ndarray: return self.normalized_landmarks.flatten()

class DataCollectionSession:
    def __init__(self, label: str, target_samples: int, delay: int):
        self.label = label
        self.target_samples = target_samples
        self.delay = delay
        self.collected_samples = 0
        self.start = datetime.now()
        self.sequences: List[List[np.ndarray]] = [] # type: ignore
        self.images: List[np.ndarray] = [] # type: ignore

    @property
    def is_complete(self) -> bool: return self.collected_samples >= self.target_samples
    @property
    def progress_percentage(self) -> float: return (self.collected_samples / self.target_samples) * 100

===== engine.py =====
import logging
import threading
import time

import cv2
import numpy as np
from data_collection.observers import Subject
from data_collection.config import Config
from data_collection.core_procs import HandProcessor, CameraManager, FileManager
from data_collection.data_models import DataCollectionSession
from typing import Optional, List

class DataCollectionEngine(Subject): # data_collection's most important code
    def __init__(self, config: Config):
        super().__init__() # Subject .__init__()
        self.config = config
        self.hand_proc = HandProcessor(config)
        self.cam_mgr = CameraManager(config)
        self.file_mgr = FileManager(config)

        self.current_session: Optional[DataCollectionSession] = None
        self.current_sequence: List[np.ndarray] = []
        self.is_collecting = False
        self.stop_request = False

    def start_session(self, label: str, samples: int, delay: int) -> bool:
        if self.is_collecting:
            return False
        
        if not self.cam_mgr.initialize():
            self.notifyAllObservers('error', 'Failed to initialize camera!')
            return False
        
        self.current_session = DataCollectionSession(label, samples, delay)
        self.is_collecting = True
        self.stop_request = False

        threading.Thread(target=self._collection_loop, daemon=True).start()
        return True
    
    def stop_session(self):
        self.stop_request = True
    
    def _collection_loop(self):
        try:
            while (self.is_collecting and not self.stop_request and not self.current_session.is_complete):
                self._collect_single_sample()
        except Exception as e:
            logging.error(f"ERROR: Collection error: {e}")
            self.notifyAllObservers('error', str(e))
        finally:
            self._cleanup() 

    def _collect_single_sample(self):
        self._countdown()

        if self.stop_request:
            return
        
        self._sequence_collection()

        if len(self.current_session) >= self.config.SEQUENCE_LENGTH:
            self._current_sample_save()
            self.current_session.collected_samples += 1
            self.notifyAllObservers('sample_completed', self.current_session)

    def _countdown(self):
        for i in range(self.current_session.delay, 0, -1):
            if self.stop_request:
                return
            ret, frame = self.cam_mgr.read_frame()
            if not ret:
                continue

            self._countdown_text_draw(frame, i)
            self.notifyAllObservers('frame_update', frame)
            time.sleep(1) # 1s

    def _sequence_collection(self):
        self.current_sequence = []
        image_captured = False

        while len(self.current_sequence) < self.config.SEQUENCE_LENGTH:
            if self.stop_request:
                return
            ret, frame = self.cam_mgr.read_frame()
            if not ret:
                continue

            results, hand_landmarks = self.hand_proc.process_frame(frame)

            if hand_landmarks: 
                if not image_captured:
                    # naga-capture laang sa first detection
                    threading.Thread(
                        target=self._image_save_async,
                        args=(frame.copy(),),
                        daemon=True
                    ).start()
                    image_captured = True
                
                landmark_vector = self.hand_proc.landmarks_to_vector(hand_landmarks)
                self.current_sequence.append(landmark_vector)
            
            # drawinf hands and progs
            frame = self.hand_proc.draw_landmarks(frame, results)
            self._collection_progress_draw(frame)
            self.notifyAllObservers('frame_update', frame)
            
            cv2.waitKey(1)

    def _image_save_async(self, frame: np.ndarray):
        self.file_mgr.frame_image_save(frame, self.current_session.label)

    def _current_sample_save(self):
        threading.Thread(
            target=self._sequence_save_async,
            args=(self.current_sequence.copy(),),
            daemon=True
        ).start()

    def _sequence_save_async(self, sequence: List[np.ndarray]):
        self.file_mgr.sequence_save(sequence, self.current_session.label)

    def _countdown_text_draw(self, frame: np.ndarray, countdown: int):
        text = f"Starting in {countdown}s..."
        cv2.putText(
            frame,
            text,
            (30, 50),
            self.config.FONT,
            1.0,
            self.config.COUNTDOWN_COLOR,
            self.config.FONT_THICKNESS
        )
        
    def _collection_progress_draw(self, frame: np.ndarray):
        prog_txt = f"Collecting {self.current_session.label}: {len(self.current_sequence)}/{self.config.SEQUENCE_LENGTH}"
        cv2.putText(
            frame, 
            prog_txt, 
            (10, 40), 
            self.config.FONT, 
            self.config.FONT_SCALE, 
            self.config.COLLECTING_COLOR, 
            self.config.FONT_THICKNESS
        )

        session_prog = f"Sample {self.current_session.collected_samples + 1}/{self.current_session.target_samples}"
        cv2.putText(
            frame,
            session_prog,
            (10, 70),
            self.config.FONT,
            self.config.FONT_SCALE,
            self.config.COLLECTING_COLOR,
            self.config.FONT_THICKNESS
        )

    def _cleanup(self):
        self.cam_mgr.release()
        cv2.destroyAllWindows()
        self.is_collecting = False
        self.notifyAllObservers('session_completed', self.current_session)




===== observers.py =====
from abc import ABC, abstractmethod
from typing import Any, List

class AbstractObserver(ABC):
    @abstractmethod
    def update(self, event_type: str, data: Any):
        pass

class Subject:
    def __init__(self):
        self._observers: List[AbstractObserver] = []

    def attach(self, observer: AbstractObserver):
        self._observers.append(observer)

    def detach(self, observer: AbstractObserver):
        self._observers.remove(observer)

    def notifyAllObservers(self, event_type: str, data: Any = None):
        for observer in self._observers:
            observer.update(event_type, data)

===== user_interface.py =====
from tkinter import StringVar, IntVar, Tk, messagebox, Label, OptionMenu, Entry, Button
from typing import Any

import cv2
from data_collection.observers import AbstractObserver
from data_collection.config import Config
from data_collection.engine import DataCollectionEngine

class ASLDataCollectorUI(AbstractObserver): # da UI
    def __init__(self, config: Config):
        self.config = config
        self.engine = DataCollectionEngine(config)
        self.engine.attach(self)
        self.root = Tk()
        self.root.title('ASL Data Collector')
        self.root.geometry("400x300")



        self.label_var = StringVar(value=config.LABELS[0])
        self.num_samples_var = IntVar(value=config.DEFAULT_SAMPLES)
        self.delay_var = IntVar(value=config.DEFAULT_DELAY)
        
        self.start_button = None
        self.stop_button = None
        self.status_label = None
        
        self._setup_ui()

    def _setup_ui(self):
        # tanginang layout code to
        Label(
            self.root, 
            text="Sign Label:", 
            font=("Arial", 10, "bold")
            ).grid(row=0, column=0, padx=10, pady=10, sticky="e")
        OptionMenu(
            self.root, 
            self.label_var, 
            *self.config.LABELS
            ).grid( row=0, column=1, padx=10, pady=10, sticky="w")
        Label(
            self.root, 
            text="Samples to collect:", 
            font=("Arial", 10, "bold")
            ).grid( row=1, column=0, padx=10, pady=5, sticky="e") 
        Entry(
            self.root, 
            textvariable=self.num_samples_var, 
            width=10
            ).grid( row=1, column=1, padx=10, pady=5, sticky="w")
        Label(
            self.root, 
            text="Countdown delay (s):", 
            font=("Arial", 10, "bold")
            ).grid( row=2, column=0, padx=10, pady=5, sticky="e")
        Entry(
            self.root, 
            textvariable=self.delay_var, 
            width=10
            ).grid( row=2, column=1, padx=10, pady=5, sticky="w")
        
        button_frame = Label(self.root)
        button_frame.grid(row=3, column=0, columnspan=2, pady=20)
        
        self.start_button = Button(
            button_frame, 
            text="START COLLECTION", 
            command=self._start_collection, 
            bg="green", 
            fg="white", 
            font=("Arial", 12, "bold")
            )
        self.start_button.pack(side="left", padx=10)
        
        self.stop_button = Button(
            button_frame, 
            text="STOP", 
            command=self._stop_collection, 
            bg="red", 
            fg="white", 
            font=("Arial", 12, "bold"), 
            state="disabled"
            )
        self.stop_button.pack(side="left", padx=10)
        
        self.status_label = Label(
            self.root, 
            text="Ready to collect data", 
            font=("Arial", 10), 
            fg="blue"
            )
        self.status_label.grid( row=4, column=0, columnspan=2, pady=10 )
        
        instructions = ("Instructions:\n"
                       "1. Select the sign label\n"
                       "2. Set number of samples and countdown delay\n"
                       "3. Click START COLLECTION\n"
                       "4. Perform the sign when countdown ends\n"
                       "5. Press 'q' during collection to quit early")
        Label(
            self.root, 
            text=instructions, 
            font=("Arial", 9), 
            justify="left", 
            fg="gray"
            ).grid(row=5, column=0, columnspan=2, padx=20, pady=20, sticky="w")
        
        # kaya lowkey ayaw ko mag layout design sa tkinter eh


    def _start_collection(self):
        if self._validate_inputs():
            success = self.engine.start_session(
                self.label_var.get(),
                self.num_samples_var.get(),
                self.delay_var.get()
            )
            if success:
                self.start_button.config(state="disabled")
                self.stop_button.config(state="normal")

    def _stop_collection(self):
        self.engine.stop_session()
        self.start_button.config(state="normal")
        self.stop_button.config(state="disabled")

    def _validate_inputs(self) -> bool:
        try:
            if self.num_samples_var.get() <= 0:
                raise ValueError("Number of samples must be positive")
            if self.delay_var.get() < 0:
                raise ValueError("Delay cannot be negative")
            return True
        except ValueError as e:
            messagebox.showerror("Invalid Input", str(e))
            return False

    def update(self, event_type: str, data: Any):
        # naga-handle dito ng messages by engine
        # event_type: error, sample_completed, frame_update, session_completed
        if event_type == "error":
            messagebox.showerror("Error", data)
            self.start_button.config(state="normal")
            self.stop_button.config(state="disabled")
            self.status_label.config(text="Error occurred - Ready to collect data")
        elif event_type == "sample_completed":
            session = data
            self.status_label.config(
                text=f"Collected {session.collected_samples}/{session.target_samples} samples"
            )
        elif event_type == "frame_update":
            cv2.imshow("ASL Data Collector", data)
            key = cv2.waitKey(1) & 0xFF
            if key == ord('q'):
                self.engine.stop_session()
        
        elif event_type == "session_completed":
            session = data
            self.start_button.config(state="normal")
            self.stop_button.config(state="disabled")
            self.status_label.config(
                text=f"Collection complete! Collected {session.collected_samples} samples"
            )
            messagebox.showinfo("Complete", 
                              f"Successfully collected {session.collected_samples} samples "
                              f"for sign '{session.label}'")

    def run(self):
        try:
            self.root.mainloop()
        finally:
            self.engine.stop_session()

===== __init__.py =====
"""
don't delete, very important empty python file
"""

